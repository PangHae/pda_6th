# 📊 AWS EC2 인스턴스별 성능 비교

## ⭐ 목적

50명의 동시 사용자가 EC2 기반 웹 서비스에 접속하여 100, 1000, 5000번의 요청을 할 때의 서버 응답 시간, 처리량을 측정합니다.
여러 인스턴스 유형으로 테스트 한 후 **응답 시간**, **처리량**, **비용 대비 효율**에 따른 적절한 인스턴스 유형을 알아봅니다.

## 📌 개요
Flask 기반 API(`/api/calc`)의 연산 성능을 AWS EC2 인스턴스 유형별로 측정하고, **응답 시간**, **처리량**, **비용 대비 효율**을 종합적으로 비교했습니다.

- **실행 연산**: `sum([i**2 for i in range(1, 100000)])`  
- **성격**: 컴퓨팅 집약적 (CPU 성능 중심)

## 🖥️ 테스트 코드

```python
from flask import Flask
app = Flask(__name__)
@app.route("/api/calc")
def calc():
    x = sum([i**2 for i in range(1, 100000)])  # CPU 부하
    return str(x)  #단순 문자열로 반환
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

hey 테스트 실행 코드
```
hey -n 1000 -c 50 http://localhost:8080/api/calc
```

이때 포트번호는 EC2 설정할때 작성한 포트번호로 넣어주면 되고 localhost 부분에 퍼블릭 IP주소를 넣어주면 됩니다.
그리고 -n 뒤에있는 1000은 요청량 -c 뒤에있는 50은 동시접속자 수  이므로 이를 적절히 변경해가면서 실험을 진행했습니다. 


## 🧪 테스트 환경

| 항목               | 내용                                       |
|--------------------|--------------------------------------------|
| 테스트 도구        | [`hey`](https://github.com/rakyll/hey)     |
| 요청 수 (`-n`)     | 100 / 1,000 / 5,000                         |
| 동시 접속자 수 (`-c`)| 50                                       |
| 실행 횟수          | 조건당 3회 평균                            |
| 응답 데이터        | 단순 문자열 (`str(x)`)                     |

## 💻 테스트 대상 인스턴스

| 인스턴스 유형 | vCPU | RAM  | 온디맨드 요금 ($/시간) |
|---------------|------|------|--------------------------|
| t2.nano        | 1    | 0.5GB | 0.0058                   |
| t2.xlarge      | 4    | 16GB  | 0.1856                   |
| t3.nano        | 2    | 0.5GB | 0.0052                   |
| t3.xlarge      | 4    | 16GB  | 0.1664                   |
| c5.large       | 2    | 4GB   | 0.0850                   |
| c5.xlarge      | 4    | 8GB   | 0.1700                   |
| m5.large       | 2    | 8GB   | 0.0960                   |
| m5.xlarge      | 4    | 16GB  | 0.1920                   |

---

## ⏱ 평균 응답 시간 (초)

![output (3)](https://github.com/user-attachments/assets/168370ca-647a-42b9-8925-93c64525fef3)



| 요청 수 | t2.nano | t2.xlarge | t3.nano | t3.xlarge | m5.large | m5.xlarge | c5.large | c5.xlarge |
|----------|---------|-----------|---------|-----------|----------|-----------|----------|-----------|
| 100      | 0.2885  | 0.2863    | 0.3420  | 0.3465    | 0.3233   | 0.3286    | 0.2726   | 0.2967    |
| 1000     | 0.3530  | 0.3648    | 0.4231  | 0.4390    | 0.3963   | 0.4105    | 0.3332   | 0.3365    |
| 5000     | 0.3602  | 0.3715    | 0.4540  | 0.4661    | 0.4092   | 0.4098    | 0.3363   | 0.3262    |

## ⚡ 초당 요청 처리량 (Requests/sec)

| 요청 수 | t2.nano | t2.xlarge | t3.nano | t3.xlarge | m5.large | m5.xlarge | c5.large | c5.xlarge |
|----------|---------|-----------|---------|-----------|----------|-----------|----------|-----------|
| 100      | 134.34  | 133.16    | 114.34  | 115.75    | 120.24   | 122.38    | 143.07   | 141.39    |
| 1000     | 138.32  | 133.78    | 115.43  | 111.25    | 123.32   | 121.97    | 146.97   | 145.86    |
| 5000     | 138.14  | 133.94    | 109.65  | 106.85    | 121.37   | 121.79    | 146.60   | 148.01    |

---

## 💵 가격 대비 성능 분석

![image](https://github.com/user-attachments/assets/e98c9e4e-edfd-4831-8c6b-eaefffb7744a)

| 인스턴스   | 요금 ($/h) | 평균 응답 (1000req) | 처리량 RPS | 요청/초 ÷ 비용 |
|------------|------------|----------------------|-------------|-----------------|
| t3.nano    | 0.0052     | 0.4231               | 115.43      | **22,198**      |
| t2.nano    | 0.0058     | 0.3530               | 138.32      | **23,849**      |
| t3.xlarge  | 0.1664     | 0.4390               | 111.25      | **668**         |
| t2.xlarge  | 0.1856     | 0.3648               | 133.78      | **721**         |
| c5.large   | 0.0850     | 0.3332               | 146.97      | **1,729**       |
| c5.xlarge  | 0.1700     | 0.3365               | 145.86      | **858**         |
| m5.large   | 0.0960     | 0.3963               | 123.32      | **1,284**       |
| m5.xlarge  | 0.1920     | 0.4105               | 121.97      | **635**         |
---

## 🔎 인스턴스별 특성 요약

### ✅ T 계열 (t2, t3)
- **버스트 성능 기반**: CPU 크레딧으로 제한적 고성능 발휘
- **지속 CPU 작업에는 부적합**
- **저렴한 비용, 제한적 성능**

### ✅ C 계열 (c5)
- **고성능 CPU 최적화**
- 컴퓨팅 집약적인 작업에 강력
- **가장 우수한 성능 대비 비용 효율**

### ✅ M 계열 (m5)
- 균형 잡힌 범용 인스턴스
- 실험 결과에서는 **비용 대비 성능이 C 계열보다 열세**

---


## ✅ 결론
| 인스턴스 유형                   | 평가                                                                                                                          |
| ------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| **c5.large**              | 성능과 비용 측면에서 **최고의 가성비**를 보임. 컴퓨팅 최적화 인스턴스로, 연산 부하가 많은 환경에 매우 적합함.                                                           |
| **t2.nano / t3.nano**     | **비용은 매우 저렴**하지만, 연산량이 많아질수록 처리 성능이 급격히 떨어지므로 **실서비스에서는 비효율**적일 수 있음. 간단한 테스트나 저부하 서비스에 적합.                                 |
| **t2.xlarge / t3.xlarge** | 처리 성능은 높지만 **요금 대비 효율은 낮은 편**. 성능 대비 비용 효율에서 c5.large에 밀리는 결과를 보였음. **비용 부담 없이 높은 burst 성능이 필요할 때 고려** 가능.                  |
| **m5.xlarge**             | **c5.xlarge보다 더 비싼 요금**에도 불구하고, 본 실험 환경(연산 중심 API)에서는 성능이 낮게 측정되어 **현재 테스트 범위에서는 비추천**. 단, IO/메모리 부하 환경에서는 더 나은 선택이 될 수 있음. |



이번 실험은 단일 연산 집중형 API(/api/calc)를 기준으로 한 테스트로, CPU 계산 부하 중심의 작업에 특화되어 있습니다.
그 결과, 컴퓨팅 최적화 인스턴스인 C 계열 (특히 c5.large)가 뛰어난 응답 시간과 처리량, 비용 대비 성능을 보였습니다.
반면 M 계열 인스턴스 (예: m5.large, m5.xlarge)는 CPU 성능보다는 균형 잡힌 범용 처리에 강점을 가지는 유형으로, 이번 실험에서는 그 장점을 충분히 발휘하지 못했습니다.

## 🔎 
따라서 단순히 M 계열을 '비효율적'이라고 결론짓기보다는 다음과 같은 관점이 필요합니다.
실제 서비스에서의 복합적인 I/O 작업, 예를 들어 데이터베이스 접근, 파일 처리, 네트워크 병렬 처리, 캐시 연동 등의 부하를 포함한다면 M 계열이 더 안정적일 수 있습니다.
메모리 의존도가 높은 애플리케이션에서는 C 계열보다 더 나은 퍼포먼스를 발휘할 수 있습니다.


## ⁉️t2가 더 옛날 버전인데 왜 t3보다 빠를까


지금 실행한 /api/calc는 매우 짧은 CPU 바운드 작업 이런 단기적 테스트에서는 t2의 크레딧을 다 쓰기 전에 테스트가 끝납니다. 따라서 평균 응답 시간이 더 낮음 장기 테스트(예: 10분 이상)나 실서비스 시나리오에선 보통 t3가 더 낫습니다. t2는 크레딧 소진 시 성능이 급락하고 t3는 지속 부하에도 일정 수준 성능 유지 합니다.(과금 조건 포함)

---

## ✅ 아쉬운점

- 가용영역을 통일하지 못해서 이로인한 차이가 발생했을 수 있습니다.
- 성능 테스트에서는 단순히 동시 접속자 수(N)와 총 요청 수(R)만 정해놓는 것보다, 다양한 변수(요청 간 간격, 부하 지속 시간)를 함께 고려해 구성하는 것이 보다 현실적이고 유의미한 결과를 얻는 데 적합합니다.

---

## ✅ 추가 실험 제안
- I/O 중심 API 테스트: 파일 읽기/쓰기, 디스크 캐시 작업
- 네트워크 병렬 처리 부하 테스트: 여러 외부 API 호출 등
- 메모리 활용 테스트: 대량 JSON 파싱, pandas DataFrame 연산 등
- 실제 웹 애플리케이션 부하 시나리오 구성: DB 연동 + 비동기 요청 처리
