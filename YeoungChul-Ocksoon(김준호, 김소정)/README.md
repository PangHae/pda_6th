
# ARM vs Intel 아키텍처 비교
![Intel vs ARM Comparison](picture.png)

</br>

## 기본 개념 요약
| 항목               | ARM (RISC)                                 | Intel (CISC)                                |
|--------------------|---------------------------------------------|----------------------------------------------|
| 아키텍처 방식      | RISC (Reduced Instruction Set Computer)     | CISC (Complex Instruction Set Computer)      |
| 설계 철학          | 단순한 명령어를 빠르게 실행                | 복잡한 명령어로 많은 작업을 수행            |
| 명령어 수          | 적음 (~30~50개)                             | 많음 (~100~250개)                            |
| 명령어 길이        | 고정 길이                                   | 가변 길이                                    |
| 제어 방식          | 하드와이어드 (H/W 제어)                     | 마이크로코드 (S/W 제어)                      |
---
</br>

## 성능 및 특성 비교
| 항목               | ARM                                         | Intel                                        |
|--------------------|---------------------------------------------|----------------------------------------------|
| 단일 스레드 성능   | 중간                                         |  높음 (고클럭 + 고급 최적화)              |
| 병렬 처리          |  강점 (물리 코어 다수)                   | 하이퍼스레딩 기반 논리 코어 병렬 처리       |
| 소비 전력          |  낮음                                     | 비교적 높음                                  |
| 발열               | 낮음                                        | 높음                                         |
| 캐시 구조          | 간단                                        | 고성능 다단계 캐시 구조                   |
| 파이프라인         | 간결하고 짧음                              | 복잡하지만 고성능                         |
| SIMD, AVX 지원     | 제한적 또는 없음                            | 고급 명령어 (AVX2, AVX-512 등)            |
---

</br>
</br>

## 테스트 설명

- **Intel vCPU 수 = 물리코어 수 / 2** (하이퍼스레딩 적용)
- **ARM (Graviton) vCPU 수 = 물리코어 수**
- 테스트 환경: **모든 인스턴스 Ubuntu**

</br>

## 🔬 테스트 1: 소수 세기 (멀티프로세스 성능 측정)

### ✅ 테스트 설명
- `multiprocessing` 라이브러리를 사용하여,  
  vCPU 개수만큼 프로세스를 생성
- 각 프로세스는 **1 ~ 50000** 사이의 소수를 모두 카운트
- 각 프로세스는 독립된 GIL과 메모리 공간 사용하여 멀티프로세스 동작

### ✅ 예상 결과
- **Intel이 더 빠를 것**으로 예상  
- 이유: **하이퍼스레딩**으로 물리 코어 하나당 2개 코어처럼 동작 가능하는 기술로
Graviton보다 멀티프로세스 기능이 뛰어날 걸로 예상  

### ✅ 결과

| 칩 | 인스턴스 타입 | 시간 (s) | vCPU | 물리코어 | 설명 |
|-----|----------------|-----------|-------|------------|-------|
| Intel | t3.small     | 3.97     | 2     | 1 | 물리코어 1일 때 가장 느림 |
| Intel | t2.xlarge    | 1.60     | 4     | 2 |  |
| Intel | t3.xlarge    | 1.90     | 4     | 2 |  |
| Intel | t2.2xlarge   | 1.65     | 8     | 4 |  |
| Intel | c5.4xlarge   | 1.60     | 16    | 8 |  |
| ARM   | t4g.small     | 3.04     | 2     | 2 |  |
| ARM   | t4g.xlarge    | 3.13     | 4     | 4 |  |
| ARM   | t4g.2xlarge   | 3.34     | 8     | 8 |  |
| ARM   | c8g.4xlarge   | 3.45      | 16     | 16 |  

### ✅ 총평

- **전반적으로 Intel이 빠른 성능을 보임**


</br>

## 🔬 테스트 2: 1000×1000 행렬곱 (멀티스레드 성능 측정)

### ✅ 테스트 설명
- NumPy를 사용한 행렬곱 연산 (A @ B)
- 각 연산은 약 **1,000,000번의 곱/덧셈**
- NumPy는 내부적으로 멀티스레드로 최적화된 MKL 사용

### ✅ 예상 결과
- 단순한 병렬 계산이므로, **Graviton의 멀티스레드 효율이 더 좋을 것**으로 예상됨

### ✅ 결과

| 칩 | 인스턴스 타입 | 시간 (s) | vCPU | 물리코어 | 설명 |
|-----|----------------|-----------|-------|------------|-------|
| Intel | t3.small     | 7.02     | 2     | 1 |  |
| Intel | t2.xlarge    | 3.93     | 4     | 2 |  |
| Intel | t2.2xlarge   | 3.34     | 8     | 4 |  |
| Intel | t3.xlarge    | 4.56     | 4     | 2 |  |
| Intel | c5.4xlarge   | 3.03     | 16    | 8 |  |
| ARM   | t4g.small     | 7.57     | 2     | 2 |  |
| ARM   | t4g.xlarge    | 4.95     | 4     | 4 |  |
| ARM   | t4g.2xlarge   | 3.58     | 8     | 8 |  |
| ARM   | c8g.4xlarge   | 4.85        | 16     | 16 |  |

### ✅ 총평

- 예상과 달리 **Intel이 대부분 우세**
- 이유:
  - Intel은 **클럭 + IPC**가 높음
  - NumPy는 기본적으로 `MKL(Intel 전용 고속 수치 라이브러리)`을 사용

</br>

## 🔬 테스트 3: 큐 기반 비동기 처리 (멀티스레드 수천 개 생성)

### ✅ 테스트 설명
- 작업 100개를 큐에 넣고  
 **vCPU 수 × 30,000개의 스레드**를 생성
- 각 스레드는 큐에서 작업을 꺼내 연산을 수행한 뒤 종료
- 연산 내용: 단순 반복 계산 (곱셈, 루트, 로그 등)

---

### ✅ 예상 결과
- Graviton은 vCPU = 물리코어로
- **Intel T 계열**은 **커널 스레드 수 제한, 메모리 스택 한도** 등에 걸려 **스레드 생성 실패** 가능성 있음

---

### ✅ 테스트 결과

| 칩   | 인스턴스 타입 | 시간 (초) | vCPU | 물리코어 | 설명 |
|------|----------------|-----------|------|-----------|------|
| Intel | t3.small       | -         | 2    | 1         | 스레드 생성 실패 (`RuntimeError`) |
| Intel | t2.xlarge      | 49.20     | 4    | 2         | 실행 완료 |
| Intel | t2.2xlarge     | 117.99    | 8    | 4         | 실행 완료 |
| Intel | t3.xlarge      | -         | 4    | 2         | 스레드 생성 실패 (`RuntimeError`) |
| Intel | c5.4xlarge     | 976.00    | 16   | 8         | 실행 완료 (연산량에 비해 매우 느림) |
| ARM   | t4g.small       | 25.10     | 2    | 2         | 실행 완료 |
| ARM   | t4g.xlarge      | 321.55    | 4    | 4         | 실행 완료 |
| ARM   | t4g.2xlarge     | 5분 이상 | 8    | 8         | 매우 느림 |
| ARM   | c8g.4xlarge     | 5분 이상 | 16    | 16         | 매우 느림 |

---

### ⚠️ 특이사항

- Intel T 계열(t3.small, t3.xlarge)에서 `RuntimeError: can't start new thread` 발생  

- Graviton(ARM)은 Intel보다 물리코어가 많아 더 많은 스레드 수를 감당 가능하지만,  
  → 계산 성능 자체는 낮아 처리 속도는 느림
- 반면, Intel은 물리코어 수가 더 적어 감당할 스레드는 적지만
  -> 계산 성능이 뛰어나 속도는 더 빠름

---
</br>

## 🧠 종합 결론

| 항목                        | 결론 |
|-----------------------------|-------|
| 🔢 연산 성능                | ✅ **Intel 우세** (고클럭 + MKL 최적화) |
| 🧵 멀티프로세스 병렬성      | ✅ **Intel 우세** (하이퍼스레딩 효과) |
| 🧵 스레드 생성 안정성       | ✅ **Graviton 우세** (자원 제한에 덜 민감) |
| 💡 추천 인스턴스 조건       | - **Intel**: 연산량 크고 물리 코어 2개 이상일 때 효율적<br>- **ARM(Graviton)**: 스레드 수 많은 대규모 분산 처리에 적합 |

---

</br>

> 테스트를 통해 **단순한 연산 성능만이 아니라**,  
> **시스템 자원 제한, 커널 수준 스레드 허용량, 멀티스레드 처리 안정성까지 종합적으로 고려**해야 함을 알 수 있었다.